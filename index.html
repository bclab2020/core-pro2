<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AthleteCore Pro - AIå§¿å‹¢åˆ†æã‚·ã‚¹ãƒ†ãƒ </title>
    
    <!-- MediaPipe Pose Detection -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #000 0%, #1f2937 50%, #000 100%);
            color: white;
            min-height: 100vh;
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .app-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .screen {
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            text-align: center;
        }
        
        .screen.active {
            display: flex !important;
        }
        
        .welcome-screen {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 50%, #1e40af 100%);
        }
        
        .dashboard-screen {
            background: linear-gradient(135deg, #000 0%, #374151 50%, #111827 100%);
        }
        
        .results-screen {
            background: linear-gradient(135deg, #064e3b 0%, #059669 50%, #047857 100%);
        }
        
        h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 300;
            letter-spacing: 4px;
            text-transform: uppercase;
        }
        
        p {
            font-size: 1.2rem;
            margin-bottom: 40px;
            opacity: 0.9;
        }
        
        .btn {
            background: white;
            color: #1e3a8a;
            padding: 15px 40px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 10px;
            transition: all 0.3s ease;
            min-width: 200px;
        }
        
        .btn:hover, .btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: transparent;
            color: white;
            border: 2px solid white;
        }
        
        .status-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            z-index: 1000;
        }
        
        .debug-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-family: monospace;
            max-width: 300px;
            z-index: 1000;
            display: none;
        }
        
        .camera-container {
            position: relative;
            width: 300px;
            height: 400px;
            background: #333;
            border-radius: 10px;
            margin: 20px auto;
            overflow: hidden;
        }
        
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        
        /* 4æ–¹å‘æ’®å½±ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .direction-indicator {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        
        .direction-indicator h2 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            color: #00ff00;
        }
        
        .direction-indicator p {
            font-size: 1rem;
            margin-bottom: 15px;
            opacity: 0.9;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin-bottom: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            width: 25%;
            transition: width 0.5s ease;
        }
        
        .pose-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }
        
        .countdown-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 4rem;
            font-weight: bold;
            padding: 20px;
            border-radius: 50%;
            min-width: 100px;
            min-height: 100px;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .control-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .captured-images {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        .captured-images h3 {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        .image-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .captured-item {
            position: relative;
            aspect-ratio: 3/4;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
        }
        
        .captured-item.completed {
            border-color: #00ff00;
        }
        
        .capture-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.8rem;
            opacity: 0.7;
            text-align: center;
        }
        
        .captured-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        /* æ’®å½±ãƒ¢ãƒ¼ãƒ‰é¸æŠç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .mode-selection {
            display: flex;
            gap: 20px;
            margin: 30px 0;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .mode-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            max-width: 280px;
            flex: 1;
            min-width: 250px;
        }
        
        .mode-card:hover {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
            transform: translateY(-5px);
        }
        
        .mode-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }
        
        .mode-card h3 {
            font-size: 1.4rem;
            margin-bottom: 10px;
            color: white;
        }
        
        .mode-card p {
            font-size: 0.9rem;
            margin-bottom: 15px;
            opacity: 0.8;
        }
        
        .mode-features {
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 0.8rem;
        }
        
        .mode-features span {
            color: #00ff00;
        }
        
        /* åˆ†æç”»é¢ã®ãƒ¢ãƒ¼ãƒ‰è¡¨ç¤º */
        .mode-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .mode-badge {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
            border: 1px solid #00ff00;
        }
        
        .mode-instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            max-width: 200px;
            z-index: 5;
        }
        
        /* ã‚»ãƒ«ãƒ•æ’®å½±ç”¨UI */
        .selfie-controls {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .countdown-settings {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .countdown-settings select {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        .pose-quality-indicator {
            text-align: center;
        }
        
        .pose-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
        }
        
        .pose-score {
            font-weight: bold;
            font-size: 1.1rem;
            color: #00ff00;
        }
        
        /* ä»–è€…æ’®å½±ç”¨UI */
        .assisted-controls {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .photographer-guide h4 {
            margin-bottom: 10px;
            color: #00ff00;
        }
        
        .photographer-guide p {
            margin: 5px 0;
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        /* ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³è¡¨ç¤ºã®æ”¹è‰¯ */
        .countdown-overlay {
            background: radial-gradient(circle, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.7));
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        /* çµæœç”»é¢ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .capture-mode-info {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 20px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }
        
        .overall-score {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
        }
        
        .score-circle {
            display: inline-flex;
            align-items: baseline;
            justify-content: center;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            color: black;
            font-size: 2.5rem;
            font-weight: bold;
            margin: 15px 0;
            border: 4px solid rgba(255, 255, 255, 0.3);
        }
        
        .score-circle small {
            font-size: 1rem;
            margin-left: 5px;
        }
        
        .direction-scores {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
        }
        
        .direction-scores h3 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2rem;
        }
        
        .direction-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .direction-result {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
        }
        
        .direction-result:hover {
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .direction-result img {
            width: 100%;
            max-width: 80px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .direction-result h4 {
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: white;
        }
        
        .direction-score {
            font-size: 1.1rem;
            font-weight: bold;
            color: #00ff00;
        }
        
        .detailed-analysis {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
        }
        
        .detailed-analysis h3 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2rem;
        }
        
        .analysis-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .analysis-item:last-child {
            border-bottom: none;
        }
        
        .analysis-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .analysis-value {
            font-weight: bold;
            color: #00ff00;
        }
        
        .result-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Welcome Screen -->
        <div id="welcome" class="screen welcome-screen active">
            <h1>AthleteCore Pro</h1>
            <p>AIå§¿å‹¢åˆ†æã‚·ã‚¹ãƒ†ãƒ </p>
            <button class="btn" onclick="showDashboard()">åˆ†æã‚’é–‹å§‹</button>
            <button class="btn btn-secondary" onclick="toggleDebug()">è¨ºæ–­æƒ…å ±</button>
        </div>
        
        <!-- Dashboard Screen -->
        <div id="dashboard" class="screen dashboard-screen">
            <h1>æ’®å½±ãƒ¢ãƒ¼ãƒ‰é¸æŠ</h1>
            <p>æ’®å½±æ–¹æ³•ã‚’é¸æŠã—ã¦ãã ã•ã„</p>
            
            <div class="mode-selection">
                <div class="mode-card" onclick="selectCameraMode('selfie')">
                    <div class="mode-icon">ğŸ¤³</div>
                    <h3>ã‚»ãƒ«ãƒ•æ’®å½±</h3>
                    <p>ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ã§è‡ªåˆ†ã§æ’®å½±<br>ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ä»˜ã</p>
                    <div class="mode-features">
                        <span>âœ… è‡ªå‹•ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³</span>
                        <span>âœ… ãƒãƒ¼ã‚ºã‚¬ã‚¤ãƒ‰è¡¨ç¤º</span>
                        <span>âœ… ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ä½¿ç”¨</span>
                    </div>
                </div>
                
                <div class="mode-card" onclick="selectCameraMode('assisted')">
                    <div class="mode-icon">ğŸ“¸</div>
                    <h3>ä»–è€…æ’®å½±</h3>
                    <p>ã‚¢ã‚¦ãƒˆã‚«ãƒ¡ãƒ©ã§èª°ã‹ã«<br>æ’®ã£ã¦ã‚‚ã‚‰ã†</p>
                    <div class="mode-features">
                        <span>âœ… æ‰‹å‹•æ’®å½±</span>
                        <span>âœ… é«˜ç”»è³ªã‚¢ã‚¦ãƒˆã‚«ãƒ¡ãƒ©</span>
                        <span>âœ… æ’®å½±è€…ç”¨ã‚¬ã‚¤ãƒ‰</span>
                    </div>
                </div>
            </div>
            
            <button class="btn btn-secondary" onclick="showWelcome()">æˆ»ã‚‹</button>
        </div>
        
        <!-- Multi-Direction Analysis Screen -->
        <div id="analysis" class="screen dashboard-screen">
            <div id="mode-header" class="mode-header">
                <h1 id="analysis-title">4æ–¹å‘å§¿å‹¢æ’®å½±</h1>
                <div id="mode-indicator" class="mode-badge">ğŸ“± ã‚»ãƒ«ãƒ•ãƒ¢ãƒ¼ãƒ‰</div>
            </div>
            
            <div id="direction-info" class="direction-indicator">
                <h2 id="current-direction">æ­£é¢æ’®å½±</h2>
                <p id="direction-instruction">æ­£é¢ã‚’å‘ã„ã¦ç«‹ã£ã¦ãã ã•ã„</p>
                <div class="progress-bar">
                    <div id="progress" class="progress-fill"></div>
                </div>
                <p id="progress-text">1/4 æ’®å½±</p>
            </div>
            
            <div class="camera-container">
                <video id="video" autoplay muted playsinline></video>
                <canvas id="canvas"></canvas>
                <div id="pose-overlay" class="pose-overlay"></div>
                <div id="countdown" class="countdown-overlay"></div>
                <div id="mode-instructions" class="mode-instructions"></div>
            </div>
            
            <div class="control-buttons">
                <button class="btn" id="captureBtn" onclick="startCapture()">
                    <span id="capture-text">æ’®å½±é–‹å§‹</span>
                </button>
                <button class="btn" id="switchCamera" onclick="switchCamera()" style="display: none;">
                    ğŸ“· ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆ
                </button>
                <button class="btn btn-secondary" onclick="showDashboard()">æˆ»ã‚‹</button>
            </div>
            
            <!-- ã‚»ãƒ«ãƒ•æ’®å½±ç”¨ã®è¿½åŠ UI -->
            <div id="selfie-controls" class="selfie-controls" style="display: none;">
                <div class="countdown-settings">
                    <label>ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³æ™‚é–“:</label>
                    <select id="countdown-duration">
                        <option value="3">3ç§’</option>
                        <option value="5" selected>5ç§’</option>
                        <option value="10">10ç§’</option>
                    </select>
                </div>
                <div class="pose-quality-indicator">
                    <div id="pose-status" class="pose-status">
                        <span id="pose-text">å§¿å‹¢ã‚’ç¢ºèªä¸­...</span>
                        <div id="pose-score" class="pose-score">0%</div>
                    </div>
                </div>
            </div>
            
            <!-- ä»–è€…æ’®å½±ç”¨ã®è¿½åŠ UI -->
            <div id="assisted-controls" class="assisted-controls" style="display: none;">
                <div class="photographer-guide">
                    <h4>ğŸ“¸ æ’®å½±è€…å‘ã‘ã‚¬ã‚¤ãƒ‰</h4>
                    <div id="photographer-instructions">
                        <p>è¢«å†™ä½“ãŒç”»é¢ä¸­å¤®ã«æ¥ã‚‹ã‚ˆã†ã«èª¿æ•´ã—ã¦ãã ã•ã„</p>
                        <p>å…¨èº«ãŒæ˜ ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„</p>
                    </div>
                </div>
            </div>
            
            <div class="captured-images">
                <h3>æ’®å½±æ¸ˆã¿</h3>
                <div class="image-grid">
                    <div class="captured-item" id="front-capture">
                        <div class="capture-placeholder">æ­£é¢</div>
                        <img id="front-image" style="display: none;">
                    </div>
                    <div class="captured-item" id="left-capture">
                        <div class="capture-placeholder">å·¦å´é¢</div>
                        <img id="left-image" style="display: none;">
                    </div>
                    <div class="captured-item" id="right-capture">
                        <div class="capture-placeholder">å³å´é¢</div>
                        <img id="right-image" style="display: none;">
                    </div>
                    <div class="captured-item" id="back-capture">
                        <div class="capture-placeholder">å¾Œé¢</div>
                        <img id="back-image" style="display: none;">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Results Screen -->
        <div id="results" class="screen results-screen">
            <h1>4æ–¹å‘å§¿å‹¢åˆ†æçµæœ</h1>
            <div id="capture-mode-display" class="capture-mode-info">
                <span id="mode-used">ğŸ“± ã‚»ãƒ«ãƒ•æ’®å½±ã§åˆ†æ</span>
            </div>
            
            <div id="result-content">
                <!-- ç·åˆã‚¹ã‚³ã‚¢ -->
                <div class="overall-score">
                    <h2>ç·åˆã‚¹ã‚³ã‚¢</h2>
                    <div class="score-circle">
                        <span id="overall-score">85</span>
                        <small>ç‚¹</small>
                    </div>
                    <p id="overall-assessment">è‰¯å¥½ãªå§¿å‹¢ã§ã™</p>
                </div>
                
                <!-- 4æ–¹å‘åˆ¥ã‚¹ã‚³ã‚¢ -->
                <div class="direction-scores">
                    <h3>æ–¹å‘åˆ¥åˆ†æ</h3>
                    <div class="direction-grid">
                        <div class="direction-result" id="front-result">
                            <img id="front-result-img" src="" alt="æ­£é¢">
                            <h4>æ­£é¢</h4>
                            <div class="direction-score" id="front-score">--</div>
                        </div>
                        <div class="direction-result" id="left-result">
                            <img id="left-result-img" src="" alt="å·¦å´é¢">
                            <h4>å·¦å´é¢</h4>
                            <div class="direction-score" id="left-score">--</div>
                        </div>
                        <div class="direction-result" id="right-result">
                            <img id="right-result-img" src="" alt="å³å´é¢">
                            <h4>å³å´é¢</h4>
                            <div class="direction-score" id="right-score">--</div>
                        </div>
                        <div class="direction-result" id="back-result">
                            <img id="back-result-img" src="" alt="å¾Œé¢">
                            <h4>å¾Œé¢</h4>
                            <div class="direction-score" id="back-score">--</div>
                        </div>
                    </div>
                </div>
                
                <!-- è©³ç´°åˆ†æ -->
                <div class="detailed-analysis">
                    <h3>è©³ç´°åˆ†æ</h3>
                    <div id="analysis-details">
                        <div class="analysis-item">
                            <span class="analysis-label">å…¨èº«ãƒãƒ©ãƒ³ã‚¹:</span>
                            <span class="analysis-value" id="balance-score">è‰¯å¥½</span>
                        </div>
                        <div class="analysis-item">
                            <span class="analysis-label">å§¿å‹¢ã®ä¸€è²«æ€§:</span>
                            <span class="analysis-value" id="consistency-score">å®‰å®š</span>
                        </div>
                        <div class="analysis-item">
                            <span class="analysis-label">æ”¹å–„ãƒã‚¤ãƒ³ãƒˆ:</span>
                            <span class="analysis-value" id="improvement-points">ç‰¹ã«ãªã—</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="result-actions">
                <button class="btn" onclick="resetAndStartNew()">æ–°ã—ã„åˆ†æ</button>
                <button class="btn btn-secondary" onclick="showWelcome()">ãƒ›ãƒ¼ãƒ </button>
            </div>
        </div>
    </div>
    
    <!-- Status Indicator -->
    <div class="status-indicator" id="status">
        âœ… ã‚·ã‚¹ãƒ†ãƒ æ­£å¸¸
    </div>
    
    <!-- Debug Panel -->
    <div class="debug-panel" id="debugPanel">
        <h4>ğŸ” ã‚·ã‚¹ãƒ†ãƒ è¨ºæ–­</h4>
        <div id="debugInfo"></div>
        <button onclick="toggleDebug()" style="margin-top: 10px; padding: 5px 10px; background: #333; color: white; border: none; border-radius: 3px;">é–‰ã˜ã‚‹</button>
    </div>

    <script>
        // Global variables
        let currentScreen = 'welcome';
        let pose = null;
        let camera = null;
        let isAnalyzing = false;
        
        // æ’®å½±ãƒ¢ãƒ¼ãƒ‰ç®¡ç†
        let currentCameraMode = null; // 'selfie' ã¾ãŸã¯ 'assisted'
        let currentFacingMode = 'user'; // 'user' (ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©) ã¾ãŸã¯ 'environment' (ã‚¢ã‚¦ãƒˆã‚«ãƒ¡ãƒ©)
        
        // 4æ–¹å‘æ’®å½±ç”¨å¤‰æ•°
        let captureSequence = ['front', 'left', 'right', 'back'];
        let currentCaptureIndex = 0;
        let capturedImages = {};
        let isCapturing = false;
        let countdownTimer = null;
        let countdownDuration = 5; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ5ç§’
        
        // MediaPipeç”¨å¤‰æ•°
        let poseResults = null;
        let isMediaPipeReady = false;
        let poseQualityHistory = [];
        
        console.log('ğŸš€ AthleteCore Pro - Minimal Version Loading...');
        
        // Screen management
        function showScreen(screenId) {
            console.log(`ğŸ“± Switching to screen: ${screenId}`);
            
            // Hide all screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
                screen.style.display = 'none';
            });
            
            // Show target screen
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');
                targetScreen.style.display = 'flex';
                currentScreen = screenId;
                updateStatus(`ç”»é¢: ${screenId}`);
                console.log(`âœ… Screen ${screenId} displayed successfully`);
            } else {
                console.error(`âŒ Screen ${screenId} not found`);
                updateStatus(`ã‚¨ãƒ©ãƒ¼: ç”»é¢ ${screenId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
            }
        }
        
        function showWelcome() {
            showScreen('welcome');
        }
        
        function showDashboard() {
            showScreen('dashboard');
        }
        
        function showAnalysis() {
            showScreen('analysis');
            initCamera();
        }
        
        function showResults() {
            showScreen('results');
            displayAnalysisResults();
        }
        
        function displayAnalysisResults() {
            try {
                const analysisData = JSON.parse(localStorage.getItem('latest_analysis'));
                
                if (!analysisData || !analysisData.images) {
                    console.error('âŒ No analysis data found');
                    return;
                }
                
                console.log('ğŸ“Š Displaying analysis results:', analysisData);
                
                // æ’®å½±ãƒ¢ãƒ¼ãƒ‰è¡¨ç¤º
                const modeDisplay = document.getElementById('mode-used');
                if (modeDisplay) {
                    modeDisplay.textContent = analysisData.captureMode === 'selfie' ? 
                        'ğŸ¤³ ã‚»ãƒ«ãƒ•æ’®å½±ã§åˆ†æ' : 'ğŸ“¸ ä»–è€…æ’®å½±ã§åˆ†æ';
                }
                
                // å„æ–¹å‘ã®ç”»åƒã¨ã‚¹ã‚³ã‚¢ã‚’è¡¨ç¤º
                let totalScore = 0;
                let validDirections = 0;
                
                captureSequence.forEach(direction => {
                    const imageData = analysisData.images[direction];
                    if (imageData) {
                        // ç”»åƒã‚’è¡¨ç¤º
                        const resultImg = document.getElementById(`${direction}-result-img`);
                        if (resultImg) {
                            resultImg.src = imageData.image;
                        }
                        
                        // ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ãƒ»è¡¨ç¤º
                        const score = calculateDirectionScore(imageData);
                        const scoreElement = document.getElementById(`${direction}-score`);
                        if (scoreElement) {
                            scoreElement.textContent = score + 'ç‚¹';
                            scoreElement.style.color = getScoreColor(score);
                        }
                        
                        totalScore += score;
                        validDirections++;
                    }
                });
                
                // ç·åˆã‚¹ã‚³ã‚¢ã‚’è¡¨ç¤º
                const overallScore = validDirections > 0 ? Math.round(totalScore / validDirections) : 0;
                const overallScoreElement = document.getElementById('overall-score');
                const overallAssessment = document.getElementById('overall-assessment');
                
                if (overallScoreElement) {
                    overallScoreElement.textContent = overallScore;
                }
                
                if (overallAssessment) {
                    overallAssessment.textContent = getAssessmentText(overallScore);
                    overallAssessment.style.color = getScoreColor(overallScore);
                }
                
                // ã‚¹ã‚³ã‚¢ã‚µãƒ¼ã‚¯ãƒ«ã®è‰²ã‚’æ›´æ–°
                const scoreCircle = document.querySelector('.score-circle');
                if (scoreCircle) {
                    scoreCircle.style.background = `linear-gradient(135deg, ${getScoreColor(overallScore)}, ${getScoreColorDark(overallScore)})`;
                }
                
                // è©³ç´°åˆ†æã‚’è¡¨ç¤º
                displayDetailedAnalysis(analysisData, overallScore);
                
            } catch (error) {
                console.error('âŒ Error displaying analysis results:', error);
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¡¨ç¤º
                document.getElementById('overall-score').textContent = '--';
                document.getElementById('overall-assessment').textContent = 'åˆ†æãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
            }
        }
        
        function calculateDirectionScore(imageData) {
            // ãƒãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’åŸºã«è¨ˆç®—
            if (imageData.pose && imageData.pose.poseLandmarks) {
                const quality = analyzePoseQuality(imageData.pose.poseLandmarks);
                return quality ? Math.round(quality.overall) : 50;
            }
            
            // ãƒãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯åŸºæœ¬ã‚¹ã‚³ã‚¢
            return 75 + Math.floor(Math.random() * 20); // 75-95ã®ç¯„å›²ã§ãƒ©ãƒ³ãƒ€ãƒ 
        }
        
        function getScoreColor(score) {
            if (score >= 80) return '#00ff00';      // ç·‘
            if (score >= 60) return '#ffff00';      // é»„
            if (score >= 40) return '#ff8800';      // ã‚ªãƒ¬ãƒ³ã‚¸
            return '#ff4444';                       // èµ¤
        }
        
        function getScoreColorDark(score) {
            if (score >= 80) return '#00cc00';      
            if (score >= 60) return '#cccc00';      
            if (score >= 40) return '#cc6600';      
            return '#cc3333';                       
        }
        
        function getAssessmentText(score) {
            if (score >= 85) return 'âœ… å„ªç§€ãªå§¿å‹¢ã§ã™';
            if (score >= 70) return 'âœ… è‰¯å¥½ãªå§¿å‹¢ã§ã™';
            if (score >= 55) return 'âš ï¸ æ”¹å–„ã®ä½™åœ°ãŒã‚ã‚Šã¾ã™';
            if (score >= 40) return 'âš ï¸ æ³¨æ„ãŒå¿…è¦ã§ã™';
            return 'âŒ å¤§å¹…ãªæ”¹å–„ãŒå¿…è¦ã§ã™';
        }
        
        function displayDetailedAnalysis(analysisData, overallScore) {
            const balanceScore = document.getElementById('balance-score');
            const consistencyScore = document.getElementById('consistency-score');
            const improvementPoints = document.getElementById('improvement-points');
            
            // ãƒãƒ©ãƒ³ã‚¹ã‚¹ã‚³ã‚¢
            if (balanceScore) {
                if (overallScore >= 75) {
                    balanceScore.textContent = 'è‰¯å¥½';
                    balanceScore.style.color = '#00ff00';
                } else if (overallScore >= 55) {
                    balanceScore.textContent = 'æ™®é€š';
                    balanceScore.style.color = '#ffff00';
                } else {
                    balanceScore.textContent = 'è¦æ”¹å–„';
                    balanceScore.style.color = '#ff8800';
                }
            }
            
            // ä¸€è²«æ€§ã‚¹ã‚³ã‚¢
            if (consistencyScore) {
                const directions = Object.keys(analysisData.images).length;
                if (directions === 4) {
                    consistencyScore.textContent = 'å®‰å®š';
                    consistencyScore.style.color = '#00ff00';
                } else {
                    consistencyScore.textContent = 'ä¸å®Œå…¨';
                    consistencyScore.style.color = '#ffff00';
                }
            }
            
            // æ”¹å–„ãƒã‚¤ãƒ³ãƒˆ
            if (improvementPoints) {
                let points = [];
                if (overallScore < 60) points.push('å…¨ä½“çš„ãªå§¿å‹¢');
                if (overallScore < 70) points.push('ãƒãƒ©ãƒ³ã‚¹èª¿æ•´');
                
                improvementPoints.textContent = points.length > 0 ? points.join(', ') : 'ç‰¹ã«ãªã—';
                improvementPoints.style.color = points.length > 0 ? '#ffff00' : '#00ff00';
            }
        }
        
        function resetAndStartNew() {
            console.log('ğŸ”„ Starting new analysis session...');
            resetCaptureSequence();
            
            // åˆ†æãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
            localStorage.removeItem('latest_analysis');
            
            // ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«æˆ»ã‚‹
            showDashboard();
        }
        
        // Camera mode selection
        function selectCameraMode(mode) {
            console.log(`ğŸ“± Camera mode selected: ${mode}`);
            currentCameraMode = mode;
            
            if (mode === 'selfie') {
                currentFacingMode = 'user'; // ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©
                updateStatus('ã‚»ãƒ«ãƒ•æ’®å½±ãƒ¢ãƒ¼ãƒ‰é¸æŠ');
            } else if (mode === 'assisted') {
                currentFacingMode = 'environment'; // ã‚¢ã‚¦ãƒˆã‚«ãƒ¡ãƒ©
                updateStatus('ä»–è€…æ’®å½±ãƒ¢ãƒ¼ãƒ‰é¸æŠ');
            }
            
            // æ’®å½±ç”»é¢ã«é·ç§»
            showAnalysis();
        }
        
        // Analysis functions
        function showAnalysis() {
            showScreen('analysis');
            resetCaptureSequence();
            setupCameraMode();
            initCamera();
        }
        
        function setupCameraMode() {
            const modeIndicator = document.getElementById('mode-indicator');
            const selfieControls = document.getElementById('selfie-controls');
            const assistedControls = document.getElementById('assisted-controls');
            const switchCameraBtn = document.getElementById('switchCamera');
            const modeInstructions = document.getElementById('mode-instructions');
            
            if (currentCameraMode === 'selfie') {
                modeIndicator.textContent = 'ğŸ¤³ ã‚»ãƒ«ãƒ•ãƒ¢ãƒ¼ãƒ‰';
                modeIndicator.className = 'mode-badge selfie-mode';
                selfieControls.style.display = 'block';
                assistedControls.style.display = 'none';
                switchCameraBtn.style.display = 'none';
                modeInstructions.innerHTML = `
                    <strong>ã‚»ãƒ«ãƒ•æ’®å½±ãƒ¢ãƒ¼ãƒ‰</strong><br>
                    â€¢ ã‚«ãƒ¡ãƒ©ã«å‘ã‹ã£ã¦ç«‹ã£ã¦ãã ã•ã„<br>
                    â€¢ ç·‘ã®æ ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰æ’®å½±æº–å‚™OK<br>
                    â€¢ ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³å¾Œã«è‡ªå‹•æ’®å½±
                `;
            } else if (currentCameraMode === 'assisted') {
                modeIndicator.textContent = 'ğŸ“¸ ä»–è€…æ’®å½±ãƒ¢ãƒ¼ãƒ‰';
                modeIndicator.className = 'mode-badge assisted-mode';
                selfieControls.style.display = 'none';
                assistedControls.style.display = 'block';
                switchCameraBtn.style.display = 'inline-block';
                modeInstructions.innerHTML = `
                    <strong>ä»–è€…æ’®å½±ãƒ¢ãƒ¼ãƒ‰</strong><br>
                    â€¢ æ’®å½±è€…ãŒå¾Œã‚ã‚«ãƒ¡ãƒ©ã§æ’®å½±<br>
                    â€¢ è¢«å†™ä½“ã¯æŒ‡ç¤ºã«å¾“ã£ã¦ãƒãƒ¼ã‚º<br>
                    â€¢ æ‰‹å‹•ã§æ’®å½±ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™
                `;
            }
            
            // æ’®å½±ãƒœã‚¿ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
            updateCaptureButtonText();
        }
        
        function updateCaptureButtonText() {
            const captureBtn = document.getElementById('captureBtn');
            const captureText = document.getElementById('capture-text');
            
            if (currentCameraMode === 'selfie') {
                captureText.textContent = 'ã‚»ãƒ«ãƒ•æ’®å½±é–‹å§‹';
            } else if (currentCameraMode === 'assisted') {
                captureText.textContent = 'æ’®å½±ã™ã‚‹';
            }
        }
        
        // Camera functions
        async function initCamera() {
            console.log(`ğŸ“¹ Initializing camera (${currentFacingMode} mode)...`);
            try {
                const video = document.getElementById('video');
                
                // æ—¢å­˜ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åœæ­¢
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                }
                
                const constraints = {
                    video: { 
                        facingMode: currentFacingMode,
                        width: { ideal: 720 },
                        height: { ideal: 1280 }
                    }
                };
                
                console.log('ğŸ“¹ Requesting camera with constraints:', constraints);
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                // ã‚«ãƒ¡ãƒ©ãŒå®Ÿéš›ã«é–‹å§‹ã•ã‚Œã‚‹ã®ã‚’å¾…ã¤
                await new Promise((resolve) => {
                    video.addEventListener('loadedmetadata', resolve, { once: true });
                });
                
                updateStatus('ã‚«ãƒ¡ãƒ©æº–å‚™å®Œäº†');
                console.log(`âœ… Camera initialized successfully (${currentFacingMode})`);
                
                // MediaPipeåˆæœŸåŒ–
                if (!isMediaPipeReady) {
                    await initMediaPipe();
                } else {
                    startPoseDetection();
                }
                
                // ã‚»ãƒ«ãƒ•æ’®å½±ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€ãƒãƒ¼ã‚ºå“è³ªç›£è¦–ã‚’é–‹å§‹
                if (currentCameraMode === 'selfie') {
                    startPoseQualityMonitoring();
                }
                
            } catch (error) {
                console.error('âŒ Camera initialization failed:', error);
                updateStatus('ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼: ' + error.message);
                
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šåå¯¾ã®ã‚«ãƒ¡ãƒ©ã‚’è©¦è¡Œ
                if (currentFacingMode === 'environment') {
                    console.log('ğŸ”„ Trying fallback to front camera...');
                    currentFacingMode = 'user';
                    setTimeout(() => initCamera(), 1000);
                } else {
                    alert('ã‚«ãƒ¡ãƒ©ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‡ãƒã‚¤ã‚¹ã®ã‚«ãƒ¡ãƒ©è¨±å¯ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                }
            }
        }
        
        async function switchCamera() {
            console.log('ğŸ”„ Switching camera...');
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            await initCamera();
            
            const switchBtn = document.getElementById('switchCamera');
            switchBtn.textContent = currentFacingMode === 'user' ? 'ğŸ“· ãƒªã‚¢ã‚«ãƒ¡ãƒ©' : 'ğŸ“· ãƒ•ãƒ­ãƒ³ãƒˆã‚«ãƒ¡ãƒ©';
        }
        
        function startCapture() {
            if (isCapturing) {
                console.log('â¸ï¸ Capture already in progress');
                return;
            }
            
            if (currentCameraMode === 'selfie') {
                startSelfieCapture();
            } else if (currentCameraMode === 'assisted') {
                capturePhoto();
            }
        }
        
        function startSelfieCapture() {
            console.log('ğŸ¤³ Starting selfie capture sequence...');
            
            // ãƒãƒ¼ã‚ºå“è³ªãƒã‚§ãƒƒã‚¯
            const avgQuality = poseQualityHistory.length > 0 ? 
                poseQualityHistory.reduce((a, b) => a + b) / poseQualityHistory.length : 0;
                
            if (avgQuality < 70) {
                alert('å§¿å‹¢ãŒå®‰å®šã—ã¦ã„ã¾ã›ã‚“ã€‚ç·‘ã®æ ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã¾ã§å¾…ã£ã¦ã‹ã‚‰æ’®å½±ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            isCapturing = true;
            countdownDuration = parseInt(document.getElementById('countdown-duration').value);
            
            updateCaptureButtonText();
            showCountdown(countdownDuration);
        }
        
        function showCountdown(seconds) {
            const countdownOverlay = document.getElementById('countdown');
            countdownOverlay.style.display = 'flex';
            countdownOverlay.textContent = seconds;
            
            console.log(`â° Countdown: ${seconds}`);
            
            if (seconds > 0) {
                // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³éŸ³ã‚’é³´ã‚‰ã™ï¼ˆå¯èƒ½ãªå ´åˆï¼‰
                playCountdownSound();
                
                countdownTimer = setTimeout(() => {
                    showCountdown(seconds - 1);
                }, 1000);
            } else {
                countdownOverlay.textContent = 'ğŸ“¸';
                setTimeout(() => {
                    countdownOverlay.style.display = 'none';
                    capturePhoto();
                }, 500);
            }
        }
        
        function capturePhoto() {
            console.log(`ğŸ“¸ Capturing photo for ${captureSequence[currentCaptureIndex]} direction...`);
            
            const video = document.getElementById('video');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’å‹•ç”»ã«åˆã‚ã›ã‚‹
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            // å‹•ç”»ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æç”»
            ctx.drawImage(video, 0, 0);
            
            // ã‚»ãƒ«ãƒ•æ’®å½±ã®å ´åˆã¯é¡åƒã‚’ä¿®æ­£
            if (currentCameraMode === 'selfie' && currentFacingMode === 'user') {
                ctx.scale(-1, 1);
                ctx.drawImage(video, -canvas.width, 0);
            }
            
            // ãƒãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ã‚‚ä¸€ç·’ã«ä¿å­˜
            const currentDirection = captureSequence[currentCaptureIndex];
            const imageData = canvas.toDataURL('image/jpeg', 0.8);
            
            capturedImages[currentDirection] = {
                image: imageData,
                pose: poseResults ? JSON.parse(JSON.stringify(poseResults)) : null,
                timestamp: Date.now(),
                direction: currentDirection,
                cameraMode: currentCameraMode
            };
            
            // æ’®å½±æ¸ˆã¿ç”»åƒã‚’è¡¨ç¤º
            updateCapturedImageDisplay(currentDirection, imageData);
            
            // æ¬¡ã®æ’®å½±ã«é€²ã‚€
            proceedToNextCapture();
        }
        
        function updateCapturedImageDisplay(direction, imageData) {
            const imageElement = document.getElementById(`${direction}-image`);
            const captureItem = document.getElementById(`${direction}-capture`);
            
            if (imageElement && captureItem) {
                imageElement.src = imageData;
                imageElement.style.display = 'block';
                captureItem.classList.add('completed');
                
                // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’éš ã™
                const placeholder = captureItem.querySelector('.capture-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'none';
                }
            }
        }
        
        function proceedToNextCapture() {
            currentCaptureIndex++;
            isCapturing = false;
            
            if (currentCaptureIndex < captureSequence.length) {
                // æ¬¡ã®æ–¹å‘ã®æ’®å½±æº–å‚™
                updateDirectionUI();
                updateCaptureButtonText();
                
                // æ¬¡ã®æ’®å½±ã¾ã§å°‘ã—é–“éš”ã‚’ç©ºã‘ã‚‹
                setTimeout(() => {
                    if (currentCameraMode === 'selfie') {
                        // ã‚»ãƒ«ãƒ•æ’®å½±ã¯è‡ªå‹•ã§æ¬¡ã¸
                        // alert(`æ¬¡ã¯${getDirectionName(captureSequence[currentCaptureIndex])}ã®æ’®å½±ã§ã™ã€‚æº–å‚™ãŒã§ããŸã‚‰æ’®å½±ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`);
                    }
                }, 1000);
            } else {
                // å…¨æ–¹å‘ã®æ’®å½±å®Œäº†
                completeCapture();
            }
        }
        
        function updateDirectionUI() {
            const currentDirection = captureSequence[currentCaptureIndex];
            const directionElement = document.getElementById('current-direction');
            const instructionElement = document.getElementById('direction-instruction');
            const progressElement = document.getElementById('progress');
            const progressText = document.getElementById('progress-text');
            
            const directionNames = {
                'front': 'æ­£é¢æ’®å½±',
                'left': 'å·¦å´é¢æ’®å½±', 
                'right': 'å³å´é¢æ’®å½±',
                'back': 'å¾Œé¢æ’®å½±'
            };
            
            const instructions = {
                'front': 'æ­£é¢ã‚’å‘ã„ã¦ç«‹ã£ã¦ãã ã•ã„',
                'left': 'å·¦ã‚’å‘ã„ã¦ç«‹ã£ã¦ãã ã•ã„ï¼ˆæ¨ªå‘ãï¼‰',
                'right': 'å³ã‚’å‘ã„ã¦ç«‹ã£ã¦ãã ã•ã„ï¼ˆæ¨ªå‘ãï¼‰', 
                'back': 'å¾Œã‚ã‚’å‘ã„ã¦ç«‹ã£ã¦ãã ã•ã„'
            };
            
            if (directionElement) directionElement.textContent = directionNames[currentDirection];
            if (instructionElement) instructionElement.textContent = instructions[currentDirection];
            if (progressElement) {
                const progressPercent = ((currentCaptureIndex + 1) / captureSequence.length) * 100;
                progressElement.style.width = progressPercent + '%';
            }
            if (progressText) progressText.textContent = `${currentCaptureIndex + 1}/${captureSequence.length} æ’®å½±`;
        }
        
        function completeCapture() {
            console.log('ğŸ‰ All 4 directions captured successfully!');
            updateStatus('å…¨æ–¹å‘æ’®å½±å®Œäº†');
            
            // æ’®å½±å®Œäº†ã®åŠ¹æœéŸ³ï¼ˆå¯èƒ½ãªå ´åˆï¼‰
            playCompletionSound();
            
            // çµæœç”»é¢ã«é·ç§»
            setTimeout(() => {
                prepareResults();
                showResults();
            }, 1000);
        }
        
        function prepareResults() {
            // æ’®å½±çµæœã‚’åˆ†æç”¨ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦æº–å‚™
            const analysisData = {
                captureMode: currentCameraMode,
                captureTimestamp: Date.now(),
                images: capturedImages,
                totalDirections: captureSequence.length
            };
            
            // localStorage ã«ä¿å­˜
            try {
                localStorage.setItem('latest_analysis', JSON.stringify(analysisData));
                console.log('âœ… Analysis data saved to localStorage');
            } catch (error) {
                console.error('âŒ Failed to save analysis data:', error);
            }
        }
        
        // éŸ³éŸ¿åŠ¹æœï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        function playCountdownSound() {
            try {
                // Web Audio APIã‚’ä½¿ç”¨ã—ã¦ãƒ“ãƒ¼ãƒ—éŸ³ã‚’ç”Ÿæˆ
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                gainNode.gain.value = 0.1;
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (error) {
                // éŸ³éŸ¿åŠ¹æœãŒåˆ©ç”¨ã§ããªã„å ´åˆã¯ç„¡è¦–
                console.log('Audio context not available');
            }
        }
        
        function playCompletionSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 1200;
                oscillator.type = 'sine';
                gainNode.gain.value = 0.15;
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (error) {
                console.log('Audio context not available');
            }
        }
        
        // MediaPipe functions
        async function initMediaPipe() {
            console.log('ğŸ§  Initializing MediaPipe...');
            let retryCount = 0;
            const maxRetries = 3;
            
            const attemptInit = async () => {
                try {
                    if (typeof Pose !== 'undefined') {
                        console.log(`ğŸ”„ MediaPipe initialization attempt ${retryCount + 1}/${maxRetries}`);
                        
                        pose = new Pose({
                            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                        });
                        
                        // ãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ–è¨­å®š
                        const isMobile = /Mobile|Android|iPhone|iPad/i.test(navigator.userAgent);
                        pose.setOptions({
                            modelComplexity: isMobile ? 0 : 1, // ãƒ¢ãƒã‚¤ãƒ«ã§ã¯è»½é‡ãƒ¢ãƒ‡ãƒ«
                            smoothLandmarks: true,
                            enableSegmentation: false,
                            smoothSegmentation: false,
                            minDetectionConfidence: 0.6,
                            minTrackingConfidence: 0.5
                        });
                        
                        pose.onResults(onPoseResults);
                        
                        // MediaPipeæº–å‚™å®Œäº†
                        isMediaPipeReady = true;
                        console.log('âœ… MediaPipe initialized successfully');
                        updateStatus('AIåˆ†ææº–å‚™å®Œäº†');
                        
                        // ã‚«ãƒ¡ãƒ©ã¨ã®é€£æºé–‹å§‹
                        if (currentScreen === 'analysis') {
                            startPoseDetection();
                        }
                        
                    } else {
                        throw new Error('MediaPipe Pose not loaded');
                    }
                } catch (error) {
                    retryCount++;
                    console.error(`âŒ MediaPipe initialization failed (attempt ${retryCount}):`, error);
                    
                    if (retryCount < maxRetries) {
                        console.log(`â³ Retrying MediaPipe initialization in ${retryCount * 1000}ms...`);
                        setTimeout(attemptInit, retryCount * 1000);
                    } else {
                        console.error('âŒ MediaPipe initialization failed after all retries');
                        updateStatus('AIåˆæœŸåŒ–å¤±æ•—');
                        alert('å§¿å‹¢åˆ†æAIã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’æ›´æ–°ã—ã¦ãã ã•ã„ã€‚');
                    }
                }
            };
            
            await attemptInit();
        }
        
        function startPoseDetection() {
            if (!pose || !isMediaPipeReady) {
                console.log('â³ MediaPipe not ready, waiting...');
                setTimeout(startPoseDetection, 500);
                return;
            }
            
            const video = document.getElementById('video');
            if (!video || !video.srcObject) {
                console.log('â³ Video not ready, waiting...');
                setTimeout(startPoseDetection, 500);
                return;
            }
            
            console.log('ğŸ¯ Starting pose detection...');
            
            const detectPose = async () => {
                if (video.readyState >= 2 && currentScreen === 'analysis') {
                    try {
                        await pose.send({ image: video });
                    } catch (error) {
                        console.error('âŒ Pose detection error:', error);
                    }
                }
                
                if (currentScreen === 'analysis') {
                    requestAnimationFrame(detectPose);
                }
            };
            
            detectPose();
        }
        
        function onPoseResults(results) {
            poseResults = results;
            
            const canvas = document.getElementById('canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const video = document.getElementById('video');
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’å‹•ç”»ã«åˆã‚ã›ã‚‹
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (results.poseLandmarks && results.poseLandmarks.length > 0) {
                console.log('ğŸ¯ Pose detected with', results.poseLandmarks.length, 'landmarks');
                
                // ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã®æç”»
                drawPoseLandmarks(ctx, results.poseLandmarks, canvas.width, canvas.height);
                
                // å§¿å‹¢ã®å“è³ªãƒã‚§ãƒƒã‚¯
                const poseQuality = analyzePoseQuality(results.poseLandmarks);
                updatePoseQuality(poseQuality);
                
            } else {
                // å§¿å‹¢ãŒæ¤œå‡ºã•ã‚Œãªã„å ´åˆ
                updatePoseQuality(null);
            }
        }
        
        function drawPoseLandmarks(ctx, landmarks, width, height) {
            // ä¸»è¦ãªé–¢ç¯€ã‚’æç”»
            const connections = [
                // èƒ´ä½“
                [11, 12], [11, 13], [12, 14], [13, 15], [14, 16],
                // å·¦è…•
                [11, 13], [13, 15], [15, 17], [15, 19], [15, 21],
                // å³è…•  
                [12, 14], [14, 16], [16, 18], [16, 20], [16, 22],
                // å·¦è„š
                [23, 25], [25, 27], [27, 29], [27, 31],
                // å³è„š
                [24, 26], [26, 28], [28, 30], [28, 32],
                // èƒ´ä½“æ¥ç¶š
                [11, 23], [12, 24], [23, 24]
            ];
            
            // æ¥ç¶šç·šã‚’æç”»
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            connections.forEach(([start, end]) => {
                if (landmarks[start] && landmarks[end] && 
                    landmarks[start].visibility > 0.5 && landmarks[end].visibility > 0.5) {
                    ctx.beginPath();
                    ctx.moveTo(landmarks[start].x * width, landmarks[start].y * height);
                    ctx.lineTo(landmarks[end].x * width, landmarks[end].y * height);
                    ctx.stroke();
                }
            });
            
            // é–¢ç¯€ç‚¹ã‚’æç”»
            ctx.fillStyle = '#ff0000';
            landmarks.forEach((landmark, index) => {
                if (landmark.visibility > 0.5) {
                    ctx.beginPath();
                    ctx.arc(landmark.x * width, landmark.y * height, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
        }
        
        function analyzePoseQuality(landmarks) {
            if (!landmarks || landmarks.length < 33) return null;
            
            try {
                // ä¸»è¦ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã®å¯è¦–æ€§ãƒã‚§ãƒƒã‚¯
                const keyPoints = [11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28];
                const visiblePoints = keyPoints.filter(i => landmarks[i] && landmarks[i].visibility > 0.5);
                const visibilityScore = (visiblePoints.length / keyPoints.length) * 100;
                
                // å§¿å‹¢ã®å®‰å®šæ€§ï¼ˆå·¦å³ã®è‚©ã®æ°´å¹³åº¦ãªã©ï¼‰
                const leftShoulder = landmarks[11];
                const rightShoulder = landmarks[12];
                let stabilityScore = 100;
                
                if (leftShoulder && rightShoulder && leftShoulder.visibility > 0.5 && rightShoulder.visibility > 0.5) {
                    const shoulderTilt = Math.abs(leftShoulder.y - rightShoulder.y);
                    stabilityScore = Math.max(0, 100 - (shoulderTilt * 500)); // å‚¾ãè£œæ­£
                }
                
                // ç·åˆã‚¹ã‚³ã‚¢
                const overallScore = (visibilityScore * 0.7 + stabilityScore * 0.3);
                
                return {
                    visibility: visibilityScore,
                    stability: stabilityScore,
                    overall: overallScore,
                    isGoodPose: overallScore > 70
                };
            } catch (error) {
                console.error('âŒ Pose quality analysis error:', error);
                return null;
            }
        }
        
        function updatePoseQuality(quality) {
            const overlay = document.getElementById('pose-overlay');
            if (!overlay) return;
            
            // ãƒãƒ¼ã‚ºå“è³ªå±¥æ­´ã«è¿½åŠ ï¼ˆã‚»ãƒ«ãƒ•ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆï¼‰
            if (currentCameraMode === 'selfie' && quality) {
                poseQualityHistory.push(quality.overall);
                if (poseQualityHistory.length > 10) {
                    poseQualityHistory.shift(); // æœ€æ–°10ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä¿æŒ
                }
            }
            
            if (quality && quality.isGoodPose) {
                overlay.style.border = '4px solid #00ff00';
                overlay.style.boxShadow = '0 0 30px rgba(0, 255, 0, 0.7)';
            } else if (quality) {
                overlay.style.border = '4px solid #ffff00';
                overlay.style.boxShadow = '0 0 30px rgba(255, 255, 0, 0.7)';
            } else {
                overlay.style.border = '4px solid #ff0000';
                overlay.style.boxShadow = '0 0 30px rgba(255, 0, 0, 0.7)';
            }
            
            // ã‚»ãƒ«ãƒ•æ’®å½±ãƒ¢ãƒ¼ãƒ‰ç”¨ã®UIæ›´æ–°
            updateSelfieUI(quality);
        }
        
        function startPoseQualityMonitoring() {
            if (currentCameraMode !== 'selfie') return;
            
            console.log('ğŸ¯ Starting pose quality monitoring for selfie mode...');
            
            const monitorQuality = () => {
                if (currentScreen === 'analysis' && currentCameraMode === 'selfie') {
                    updateSelfieUI(poseResults ? analyzePoseQuality(poseResults.poseLandmarks) : null);
                    setTimeout(monitorQuality, 200); // 200msã”ã¨ã«æ›´æ–°
                }
            };
            
            monitorQuality();
        }
        
        function updateSelfieUI(quality) {
            const poseText = document.getElementById('pose-text');
            const poseScore = document.getElementById('pose-score');
            
            if (!poseText || !poseScore) return;
            
            if (quality) {
                poseScore.textContent = Math.round(quality.overall) + '%';
                
                if (quality.isGoodPose) {
                    poseText.textContent = 'âœ… æ’®å½±æº–å‚™OKï¼';
                    poseText.style.color = '#00ff00';
                    poseScore.style.color = '#00ff00';
                } else if (quality.overall > 50) {
                    poseText.textContent = 'âš ï¸ å§¿å‹¢ã‚’èª¿æ•´ã—ã¦ãã ã•ã„';
                    poseText.style.color = '#ffff00';
                    poseScore.style.color = '#ffff00';
                } else {
                    poseText.textContent = 'âŒ å§¿å‹¢ãŒæ¤œå‡ºã§ãã¾ã›ã‚“';
                    poseText.style.color = '#ff6666';
                    poseScore.style.color = '#ff6666';
                }
            } else {
                poseText.textContent = 'ğŸ“¹ å§¿å‹¢ã‚’ç¢ºèªä¸­...';
                poseText.style.color = 'white';
                poseScore.textContent = '0%';
                poseScore.style.color = 'white';
            }
        }
        
        // Utility functions
        function updateStatus(message) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = message;
            }
            console.log('ğŸ“Š Status:', message);
        }
        
        function toggleDebug() {
            const debugPanel = document.getElementById('debugPanel');
            const isVisible = debugPanel.style.display === 'block';
            
            if (isVisible) {
                debugPanel.style.display = 'none';
            } else {
                updateDebugInfo();
                debugPanel.style.display = 'block';
            }
        }
        
        function updateDebugInfo() {
            const debugInfo = document.getElementById('debugInfo');
            const info = `
                <div>ç”»é¢: ${currentScreen}</div>
                <div>æ™‚åˆ»: ${new Date().toLocaleTimeString('ja-JP')}</div>
                <div>ç”»é¢ã‚µã‚¤ã‚º: ${window.innerWidth}x${window.innerHeight}</div>
                <div>ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: ${navigator.userAgent.substring(0, 50)}...</div>
                <div>MediaPipe: ${pose ? 'âœ… æº–å‚™å®Œäº†' : 'âŒ æœªåˆæœŸåŒ–'}</div>
                <div>ã‚«ãƒ¡ãƒ©: ${document.getElementById('video')?.srcObject ? 'âœ… æ¥ç¶šä¸­' : 'âŒ æœªæ¥ç¶š'}</div>
            `;
            debugInfo.innerHTML = info;
        }
        
        // Error handling
        window.addEventListener('error', function(event) {
            console.error('âŒ Global error:', event.error);
            updateStatus('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
            alert('ã‚¨ãƒ©ãƒ¼: ' + event.message);
        });
        
        window.addEventListener('unhandledrejection', function(event) {
            console.error('âŒ Unhandled promise rejection:', event.reason);
            updateStatus('Promise ã‚¨ãƒ©ãƒ¼');
        });
        
        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            console.log('âœ… DOM Content Loaded');
            updateStatus('ã‚¢ãƒ—ãƒªåˆæœŸåŒ–å®Œäº†');
            
            // åˆæœŸUIè¨­å®š
            resetCaptureSequence();
            
            // Update debug info every 5 seconds
            setInterval(() => {
                if (document.getElementById('debugPanel').style.display === 'block') {
                    updateDebugInfo();
                }
            }, 5000);
        });
        
        function resetCaptureSequence() {
            // æ’®å½±ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
            currentCaptureIndex = 0;
            capturedImages = {};
            isCapturing = false;
            poseQualityHistory = [];
            
            // UIã‚’ãƒªã‚»ãƒƒãƒˆ
            updateDirectionUI();
            
            // æ’®å½±æ¸ˆã¿ç”»åƒã‚’ã‚¯ãƒªã‚¢
            captureSequence.forEach(direction => {
                const imageElement = document.getElementById(`${direction}-image`);
                const captureItem = document.getElementById(`${direction}-capture`);
                const placeholder = captureItem?.querySelector('.capture-placeholder');
                
                if (imageElement) {
                    imageElement.style.display = 'none';
                    imageElement.src = '';
                }
                if (captureItem) {
                    captureItem.classList.remove('completed');
                }
                if (placeholder) {
                    placeholder.style.display = 'block';
                }
            });
        }
        
        console.log('âœ… AthleteCore Pro - Minimal Version Ready');
    </script>
</body>
</html>
